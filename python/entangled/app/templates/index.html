<html>

    <head>
        <link rel="stylesheet" href="/static/index.css?nocache={{ time }}">

        <script src="/static/jquery.3.4.1.min.js"></script>

        <script>
"use strict";
var UI_STATE_NONE = 1;
var UI_STATE_AJAX = 2;
var UI_STATE_ANIMATING = 3;
var UI_STATE_MOVING = 4;

var combat;
var ui = {state: [UI_STATE_NONE]};

var center = {x: 0, y: 0};
var cameraOffset = {dx: 0, dy: 0};
var sqrt3 = Math.sqrt(3);
var halfSqrt3 = Math.sqrt(3) / 2;

// this is the viewport canvas element that the user sees
var viewport;
var viewportCtx;
// the size of the hexes should be based on the visible viewport
var viewportHexRadius;
var viewportDX;
var viewportDY;

// this array of canvas elements hold the full grid which might be bigger
// than the viewport. all the layers have the same dimensions
var canvasLayers;
var canvasPadding = 20;

var LAYER_GRID = 0;
var LAYER_GRID_TARGET = 1;
var LAYER_GRID_TARGET_PATH = 2;
var LAYER_GRID_SELECT = 3;
var LAYER_GRID_DEBUG = 4;
var LAYER_UNIT = 5;
var LAYER_COUNT = 6;

var domActiveUnitName;
var domActiveUnitAP;
var domActiveUnitActions;
var domActionTemplate;
var domEventQueue;
var domEventTemplate;
var domSelectedHexInfoText;
var domSelectedUnitName;

var colorActionSelected;

function redraw() {
    viewportCtx.clearRect(0, 0, viewport.width, viewport.height);
    canvasLayers.forEach(function(layer) {
        viewportCtx.drawImage(layer.canvas, cameraOffset.dx, cameraOffset.dy);
    });
}

function hexFromAxial(q, r) {
    let rgrid = combat.grid[q];
    if (!rgrid) {
        return;
    }

    return rgrid[r];
}

function selectHex(hex, skipRedraw) {
    let oldHex = ui.selectedHex;
    let ctx = canvasLayers[LAYER_GRID_SELECT].ctx;

    if (oldHex) {
        if ((oldHex.q === hex.q) && (oldHex.r === hex.r)) {
            return;
        }
        clearHex(ctx, oldHex.vertices);
    }

    drawHex(ctx, hex.vertices, "rgba(0, 39, 117, 0.3)");

    domSelectedHexInfoText.text("Q: " + hex.q + " R: " + hex.r);
    if (hex.unit) {
        domSelectedUnitName.text(hex.unit.name);
    }
    else {
        domSelectedUnitName.text("")
    }

    ui.selectedHex = hex;

    if (!skipRedraw) {
        redraw();
    }
}

function clickToHex(evt) {
    let x = (evt.pageX
             - viewport.offsetLeft
             - cameraOffset.dx
             + viewportDX);
    let y = (evt.pageY
             - viewport.offsetTop
             - cameraOffset.dy
             + viewportDY);

    // https://www.redblobgames.com/grids/hexagons/#pixel-to-hex
    let q = Math.round(((x / sqrt3) - (y / 3)) / viewportHexRadius);
    let r = Math.round((y * 2 / 3) / viewportHexRadius);

    // thanks for not having integers javascript
    if (Object.is(q, -0)) {
        q = 0;
    }

    if (Object.is(r, -0)) {
        r = 0;
    }

    return hexFromAxial(q, r);
}

function drawHexPath(path) {
    // draws a line connecting the centers of each hex in path
    let layer = canvasLayers[LAYER_GRID_TARGET_PATH];
    let ctx = layer.ctx;

    ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
    ctx.setLineDash([15, 5]);
    ctx.lineJoin = "round";
    ctx.lineWidth = 10;
    ctx.strokeStyle = "#2a51fa";

    // this is probably an abuse of reduce
    ctx.beginPath();
    path.forEach(function (curr, index) {
        let hex = hexFromAxial(curr.q, curr.r);
        if (index === 0) {
            ctx.moveTo(hex.center.x, hex.center.y);
        }
        else {
            ctx.lineTo(hex.center.x, hex.center.y);
        }
    });
    ctx.stroke();
}

function uiState() {
    return ui.state[ui.state.length - 1];
}

function uiStateNoInput() {
    let state = uiState();
    return (state === UI_STATE_AJAX) || (state === UI_STATE_ANIMATING);
}

function uiStatePush(state) {
    if ((state !== UI_STATE_AJAX) && (uiState() === UI_STATE_AJAX)) {
        console.log("ui state push error", state, ui.state);
    }
    ui.state.push(state);
}

function uiStatePop(expected) {
    let popped = ui.state.pop();
    if (expected && (expected !== popped)) {
        console.log("ui state pop expected", expected,
                    "got". popped,
                    ui.state);
    }
}

function uiAjaxStart() {
    ui.state.push(UI_STATE_AJAX);
}

function uiAjaxFinish() {
    let state = ui.state.pop();
    if (state !== UI_STATE_AJAX) {
        console.log("ui state ajax finish error", state, ui.state);
    }
}

function setKeys(clickCanvas, hexRadius) {
    let keybinds = {};

    keybinds["w".charCodeAt(0)] = function() { cameraOffset.dy += 10; },
    keybinds["a".charCodeAt(0)] = function() { cameraOffset.dx += 10; },
    keybinds["s".charCodeAt(0)] = function() { cameraOffset.dy -= 10; },
    keybinds["d".charCodeAt(0)] = function() { cameraOffset.dx -= 10; },
    console.log(keybinds);

    $(window).on("keypress", function(evt) {
        let f = keybinds[evt.keyCode];

        if (f === undefined) {
            return;
        }

        console.log(evt.keyCode, evt.code);

        if (uiStateNoInput()) {
            return;
        }

        let prevCameraOffset = Object.assign({}, cameraOffset);
        f();
        if ((prevCameraOffset.dx !== cameraOffset.dx) ||
            (prevCameraOffset.dy !== cameraOffset.dy)) {
            redraw();
        }

    });


    clickCanvas.addEventListener('click', function(evt) {
        let hex = clickToHex(evt);
        if (!hex) {
            return;
        }

        switch (uiState()) {
            case UI_STATE_MOVING:
                // a map would be better but it's annoying to do the
                // two-part lookup since javascript doesn't have
                // tuple keys. could convert to a string but that's
                // gross too.
                let coord = ui.targetedCoords.find(function (coord) {
                    return (coord.q === hex.q) && (coord.r === hex.r);
                });
                if (ui.selectedHex &&
                    (ui.selectedHex === hex) &&
                    ui.targetedHexes.includes(ui.selectedHex)) {
                    uiAjaxStart();
                    $.ajax({
                        type: "POST",
                        url: "/move_active_unit",
                        contentType: "application/json",
                        dataType: "json",
                        data: JSON.stringify({
                            path: coord.path
                                ? coord.path
                                : [coord]}),
                        success: function(result) {
                            ajaxHandleCombatStep(result);
                        },
                    });
                } else {
                    if (coord && coord.path) {
                        drawHexPath(coord.path);
                    }
                    selectHex(hex, true);
                    redraw();
                }
                break;
            case UI_STATE_AJAX:
                // no clicks while waiting for an ajax request to finish
                break;
            default:
                selectHex(hex);
                break;
        }
    });
}

function axialToPoint(q, r, radius) {
    return {
        x: radius * ((sqrt3 * q) + (halfSqrt3 * r)),
        y: radius * r * 3 / 2,
    }
}

// get all the hexagon vertices given the center point and a radius
function hexVertices(centerX, centerY, radius) {
    // start at the pointy bottom and go counterclockwise
    return [
        {x: centerX, y: centerY + radius},
        {x: centerX + (halfSqrt3 * radius), y: centerY + (radius / 2)},
        {x: centerX + (halfSqrt3 * radius), y: centerY - (radius / 2)},
        {x: centerX, y: centerY - radius},
        {x: centerX - (halfSqrt3 * radius), y: centerY - (radius / 2)},
        {x: centerX - (halfSqrt3 * radius), y: centerY + (radius / 2)},
    ];
}

function drawHexPerimeter(ctx, vertices) {
    ctx.beginPath();
    let vertex = vertices[0];
    ctx.moveTo(vertex.x, vertex.y);
    for (let i = 1; i < vertices.length; i++) {
        vertex = vertices[i];
        ctx.lineTo(vertex.x, vertex.y);
    }
    ctx.closePath();
}

// ctx is a canvas 2D context
// verticess is a list like [{x: x, y: y}, ...]
// it should have 6 vertices
function drawHex(ctx, vertices, fillStyle) {
    drawHexPerimeter(ctx, vertices);

    ctx.fillStyle = fillStyle;
    ctx.fill();

    ctx.lineWidth = 1;
    ctx.strokeStyle = "black";
    ctx.stroke();
}

function clearHex(ctx, vertices) {
    let op = ctx.globalCompositeOperation;
    ctx.globalCompositeOperation = 'destination-out';
    drawHexPerimeter(ctx, vertices);
    ctx.fillStyle = "black";
    ctx.fill();
    ctx.globalCompositeOperation = op;
}

function drawUnit(ctx, centerX, centerY, fillStyle) {
    ctx.beginPath();
    ctx.arc(centerX,
            centerY,
            viewportHexRadius / 2,
            0,
            2 * Math.PI);
    ctx.fillStyle = fillStyle;
    ctx.fill();
}

function initLayers(width, height) {
    console.log("grid dimensions:", width, height);

    canvasLayers = [];
    for (let i = 0; i < LAYER_COUNT; i++) {
        let c = document.createElement("canvas");
        c.width = width;
        c.height = height;

        canvasLayers.push({
            canvas: c,
            ctx: c.getContext("2d"),
        });
    }
}

function appendEvent(evt) {
    let newElem = domEventTemplate.clone();
    let eventText = "Countdown " + evt.countdown;
    if (evt.unit_keys.length > 0) {
        eventText += " " + evt.unit_keys.join(",");
    }

    newElem.text(eventText);
    domEventQueue.append(newElem);
    newElem.show();
}

function redrawEventQueue(currEvent, events) {
    domEventQueue.empty();
    appendEvent(currEvent);
    events.forEach(appendEvent);
}

function drawTargetedHexes(newCoords, oldHexes) {
    let ctx = canvasLayers[LAYER_GRID_TARGET].ctx;

    if (oldHexes) {
        oldHexes.forEach(function(hex) { clearHex(ctx, hex.vertices); });
    }

    let targeted = [];
    newCoords.forEach(function(coord) {
        let hex = hexFromAxial(coord.q, coord.r);
        drawHex(ctx, hex.vertices, "rgba(36, 131, 255, 0.3)");
        targeted.push(hex);
    });

    return targeted;
}

// a bit ugly because we're using the async call to find the moveable hexes
function beginUnitTurn(effect, currEvent, moveCoords) {
    let coord = combat.unit_key_to_coord[effect.unit_key];
    let hex = combat.grid[coord.q][coord.r];
    let unit = hex.unit;

    selectHex(hex);

    domActiveUnitName.text(unit.name);

    // action points on this turn might be different from the unit's
    // typical amount
    let ap = "AP: ";
    for (let i = 0; i < currEvent.action_points; i++) {
        ap += "\u2022 ";
    }
    domActiveUnitAP.text(ap);

    domActiveUnitActions.empty();
    let newAction = domActionTemplate.clone();
    newAction.text("Move");
    newAction.click(function(evt) {
        if (uiStateNoInput()) {
            return;
        }

        newAction.css("background", "#ea80ff");

        ui.targetedHexes = drawTargetedHexes(moveCoords, ui.targetedHexes);
        uiStatePush(UI_STATE_MOVING);
        redraw();
    });
    domActiveUnitActions.append(newAction);
    newAction.show();

    ui.targetedCoords = moveCoords;
    ui.activeUnit = unit;
}

function handleEffect(effect, currEvent) {
    // this is probably going to be ugly
    switch (effect.key) {
        case "UnitTurnBeganEffect":
            beginUnitTurn(effect, currEvent, effect.move_coords);
            break;
    }
}

function ajaxHandleCombatStep(step) {
    // always call uiAjaxStart before the ajax call
    console.log("step:", step);

    step.effects.forEach(function(effect) {
        handleEffect(effect, step.curr_event);
    });

    // TODO: handle redrawing grid and unit changes
    redrawEventQueue(step.curr_event, step.events);
}

function combatStep() {
    uiAjaxStart();
    $.ajax({
        url: "/combat_step",
        success: function (result) {
            ajaxHandleCombatStep(result);
            uiAjaxFinish();
        },
    });
}

// @param tileToHexInfo: a function that gets any additional info from the tile
//                       to put on the hex object
function setupGridAndCanvasForTiles(tiles, tileToHexInfo) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let grid = {};

    // find the max size of a theoretical canvas that could hold the
    // entire grid. though the size of the grid is scaled to the
    // viewport. the viewport will just use an offset to figure out
    // which part of the grid is currently visible
    // 1. calculate pixel coordinates as if q=0,r=0 corresponded to (0,0)
    // 2. calculate min and max dimensions to figure out how big the canvas
    //    needs to be
    // 3. pad min and max so there's some space
    // 4. set viewport offset to be min x and min y so top left of map shows
    // 5. translate all coordinates by min x and min y to match 3.
    tiles.forEach(function(tile) {
        let hex = {};

        if (grid[tile.q] === undefined) {
            grid[tile.q] = {};
        }
        grid[tile.q][tile.r] = hex;

        hex.q = tile.q;
        hex.r = tile.r;
        hex.center = axialToPoint(tile.q, tile.r, viewportHexRadius);
        hex.vertices = hexVertices(hex.center.x, hex.center.y,
                                   viewportHexRadius);

        tileToHexInfo(tile, hex);

        hex.vertices.forEach(function(vertex) {
            minX = Math.min(minX, vertex.x);
            maxX = Math.max(maxX, vertex.x);
            minY = Math.min(minY, vertex.y);
            maxY = Math.max(maxY, vertex.y);
        });
    });

    minX -= canvasPadding;
    maxX += canvasPadding;
    minY -= canvasPadding;
    maxY += canvasPadding;

    console.log("grid x range:", minX, maxX, "y range:", minY, maxY);

    Object.getOwnPropertyNames(grid).forEach(function(q) {
        let rgrid = grid[q];
        Object.getOwnPropertyNames(rgrid).forEach(function (r) {
            let hex = grid[q][r];

            hex.center.x -= minX;
            hex.center.y -= minY;
            hex.vertices.forEach(function(unused, i, vertices) {
                vertices[i].x -= minX;
                vertices[i].y -= minY;
            });
        });
    });

    viewportDX = minX;
    viewportDY = minY;
    initLayers(maxX - minX, maxY - minY);

    return grid;
}

function drawGridOnLayers(grid) {
    Object.getOwnPropertyNames(grid).forEach(function(q) {
        let rgrid = grid[q];
        Object.getOwnPropertyNames(rgrid).forEach(function (r) {
            let hex = grid[q][r];

            drawHex(canvasLayers[LAYER_GRID].ctx,
                    hex.vertices,
                    "#00bb22");

            if (hex.unit) {
                drawUnit(canvasLayers[LAYER_UNIT].ctx,
                         hex.center.x,
                         hex.center.y,
                         (hex.unit.friendly ?
                          "#2088ff" :
                          "red"));
            }

            // XXX: this is debugging, remove later
            let debugLayer = canvasLayers[LAYER_GRID_DEBUG];
            debugLayer.ctx.font = "12px Courier New";
            debugLayer.ctx.fillStyle = "black";
            debugLayer.ctx.fillText(
                q + ", " + r,
                hex.center.x - (viewportHexRadius / 2),
                hex.center.y);
        });
    });
}

function onLoad() {
    viewport = document.getElementById("theviewport");
    viewportCtx = viewport.getContext('2d');
    viewportHexRadius = viewport.height / 15;

    domEventQueue = $("#event-queue");
    domEventTemplate = $("#event-template");
    domSelectedHexInfoText = $("#selected-hex-info-text");
    domSelectedUnitName = $("#selected-unit-name");

    domActiveUnitName = $("#active-unit-name");
    domActiveUnitAP = $("#active-unit-ap");
    domActiveUnitActions = $("#active-unit-actions");
    domActionTemplate = $("#action-template");

    $.ajax({
        url: "/combat_state",
        success: function(result) {
            combat = result;

            let tileToHexInfo = function(tile, hex) {
                if (!tile.unit_key) {
                    return;
                }

                hex.unit = combat.units[tile.unit_key];
            };

            let grid = setupGridAndCanvasForTiles(combat.tiles, tileToHexInfo);
            drawGridOnLayers(grid);
            combat.grid = grid;

            setKeys(viewport, viewportHexRadius);
            redraw();

            redrawEventQueue(combat.events[0], combat.events.slice(1));

            // once it's setup, progress the game
            combatStep();
        }
    });
}

$( window ).on("load", onLoad);
        </script>

    <head>

    <body>
        <div id="all">
            <div id="canvas-column">
                <div id="selected-info">
                    <div id="selected-unit-info">
                        <span id="selected-unit-name">&nbsp;</span>
                    </div>
                </div>

                <canvas id="theviewport" width=800 height=600></canvas>

                <div id="selected-hex-info">
                    <span id="selected-hex-info-text">&nbsp;</span>
                </div>
                <div id="active-unit">
                    <div id="active-unit-stats">
                        <div id="active-unit-name">&nbsp;</div>
                        <div id="active-unit-ap">&nbsp;</div>
                    </div>
                    <div id="active-unit-actions">
                        <button type="button" id="action-template"></button>
                    </div>
                </div>
            </div>
            <div id="event-queue-column">
                <h2>Next:</h2>
                <div id="event-queue">
                    <div id="event-template"></div>
                </div>
            </div>
        </div>
    </body>
</html>
