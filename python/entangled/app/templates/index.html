<html>

    <head>
        <link rel="stylesheet" href="/static/index.css?nocache={{ time }}">

        <script src="/static/jquery.3.4.1.min.js"></script>

        <script>
"use strict";
var combat;
var center = {x: 0, y: 0};
var cameraOffset = {dx: 0, dy: 0};
var sqrt3 = Math.sqrt(3);
var halfSqrt3 = Math.sqrt(3) / 2;

// this is the viewport canvas element that the user sees
var viewport;
var viewportCtx;
// the size of the hexes should be based on the visible viewport
var viewportHexRadius;
var viewportDX;
var viewportDY;

// this array of canvas elements hold the full grid which might be bigger
// than the viewport. all the layers have the same dimensions
var canvasLayers;
var margin = 20;

var domEventQueue;
var domEventTemplate;

function redraw() {
    viewportCtx.clearRect(0, 0, viewport.width, viewport.height);
    canvasLayers.forEach(function(layer) {
        viewportCtx.drawImage(layer.canvas, cameraOffset.dx, cameraOffset.dy);
    });
}

function hexFromAxial(q, r) {
    let rgrid = combat.grid[q];
    if (!rgrid) {
        return;
    }

    return rgrid[r];
}

function clickToHex(evt) {
    let x = (evt.pageX
             - viewport.offsetLeft
             - cameraOffset.dx
             + viewportDX);
    let y = (evt.pageY
             - viewport.offsetTop
             - cameraOffset.dy
             + viewportDY);

    // https://www.redblobgames.com/grids/hexagons/#pixel-to-hex
    let q = Math.round(((x / sqrt3) - (y / 3)) / viewportHexRadius);
    let r = Math.round((y * 2 / 3) / viewportHexRadius);

    // thanks for not having integers javascript
    if (Object.is(q, -0)) {
        q = 0;
    }

    if (Object.is(r, -0)) {
        r = 0;
    }

    return hexFromAxial(q, r);
}

function setKeys(clickCanvas, hexRadius) {
    let keybinds = {};

    keybinds["w".charCodeAt(0)] = function() { cameraOffset.dy += 10; },
    keybinds["a".charCodeAt(0)] = function() { cameraOffset.dx += 10; },
    keybinds["s".charCodeAt(0)] = function() { cameraOffset.dy -= 10; },
    keybinds["d".charCodeAt(0)] = function() { cameraOffset.dx -= 10; },
    console.log(keybinds);

    $(window).on("keypress", function(evt) {
        let f = keybinds[evt.keyCode];

        if (f === undefined) {
            return;
        }

        console.log(evt.keyCode, evt.code);

        let prevCameraOffset = Object.assign({}, cameraOffset);
        f();
        if ((prevCameraOffset.dx !== cameraOffset.dx) ||
            (prevCameraOffset.dy !== cameraOffset.dy)) {
            redraw();
        }

    });

    let clickHandler = function(event, erase) {
        let hex = clickToHex(event);
        let vertices = hex.vertices;
        let ctx = canvasLayers[1].ctx;
        clearHex(ctx, vertices);
        if (!erase) {
            drawHex(ctx, vertices, "rgba(0, 39, 117, 0.3)");
        }
        redraw();
    };

    clickCanvas.addEventListener('click', function(event) {
        clickHandler(event, false);
    });
    clickCanvas.addEventListener('dblclick', function(event) {
        clickHandler(event, true);
    });

}

function axialToPoint(q, r, radius) {
    return {
        x: radius * ((sqrt3 * q) + (halfSqrt3 * r)),
        y: radius * r * 3 / 2,
    }
}

// get all the hexagon vertices given the center point and a radius
function hexVertices(centerX, centerY, radius) {
    // start at the pointy bottom and go counterclockwise
    return [
        {x: centerX, y: centerY + radius},
        {x: centerX + (halfSqrt3 * radius), y: centerY + (radius / 2)},
        {x: centerX + (halfSqrt3 * radius), y: centerY - (radius / 2)},
        {x: centerX, y: centerY - radius},
        {x: centerX - (halfSqrt3 * radius), y: centerY - (radius / 2)},
        {x: centerX - (halfSqrt3 * radius), y: centerY + (radius / 2)},
    ];
}

function drawHexPath(ctx, vertices) {
    ctx.beginPath();
    let vertex = vertices[0];
    ctx.moveTo(vertex.x, vertex.y);
    for (let i = 1; i < vertices.length; i++) {
        vertex = vertices[i];
        ctx.lineTo(vertex.x, vertex.y);
    }
    ctx.closePath();
}

// ctx is a canvas 2D context
// verticess is a list like [{x: x, y: y}, ...]
// it should have 6 vertices
function drawHex(ctx, vertices, fillStyle) {
    drawHexPath(ctx, vertices);

    ctx.fillStyle = fillStyle;
    ctx.fill();

    ctx.strokeStyle = "black";
    ctx.stroke();
}

function clearHex(ctx, vertices) {
    let op = ctx.globalCompositeOperation;
    ctx.globalCompositeOperation = 'destination-out';
    drawHexPath(ctx, vertices);
    ctx.fillStyle = "black";
    ctx.fill()
    ctx.globalCompositeOperation = op;
}

function drawUnit(ctx, centerX, centerY, fillStyle) {
    ctx.beginPath();
    ctx.arc(centerX,
            centerY,
            viewportHexRadius / 2,
            0,
            2 * Math.PI);
    ctx.fillStyle = fillStyle;
    ctx.fill();
}

function initLayers(width, height) {
    console.log("grid dimensions:", width, height);

    canvasLayers = [];
    for (let i = 0; i < 4; i++) {
        let c = document.createElement("canvas");
        c.width = width;
        c.height = height;

        canvasLayers.push({
            canvas: c,
            ctx: c.getContext("2d"),
        });
    }
}

function appendEvent(evt) {
    let newElem = domEventTemplate.clone();
    let eventText = "Countdown " + evt.countdown;
    if (evt.unit_keys.length > 0) {
        eventText += " " + evt.unit_keys.join(",");
    }

    newElem.text(eventText);
    domEventQueue.append(newElem);
    newElem.show();
}

function redrawEventQueue(currEvent, events) {
    domEventQueue.empty();
    appendEvent(currEvent);
    events.forEach(appendEvent);
}

function onLoad() {
    viewport = document.getElementById("theviewport");
    viewportCtx = viewport.getContext('2d');
    viewportHexRadius = viewport.height / 15;

    domEventQueue = $("#event-queue");
    domEventTemplate = $("#event-template");

    $.ajax({
        url: "/combat_state",
        success: function(result) {
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            // find the max size of a theoretical canvas that could hold the
            // entire grid. though the size of the grid is scaled to the
            // viewport. the viewport will just use an offset to figure out
            // which part of the grid is currently visible
            let grid = {};
            combat = JSON.parse(result);
            combat.tiles.forEach(function(tile) {
                let hex = {};

                if (grid[tile.q] === undefined) {
                    grid[tile.q] = {};
                }
                grid[tile.q][tile.r] = hex;

                hex.q = tile.q;
                hex.r = tile.r;
                hex.center = axialToPoint(tile.q, tile.r, viewportHexRadius);
                hex.vertices = hexVertices(hex.center.x, hex.center.y,
                                           viewportHexRadius);

                if (tile.unit_key) {
                    hex.unit = combat.units[tile.unit_key];
                }

                hex.vertices.forEach(function(vertex) {
                    minX = Math.min(minX, vertex.x);
                    maxX = Math.max(maxX, vertex.x);
                    minY = Math.min(minY, vertex.y);
                    maxY = Math.max(maxY, vertex.y);
                });
            });
            combat.grid = grid;

            minX -= margin;
            maxX += margin;
            minY -= margin;
            maxY += margin;

            console.log("x range:", minX, maxX, "y range:", minY, maxY);

            viewportDX = minX;
            viewportDY = minY;
            initLayers(maxX - minX, maxY - minY);

            Object.getOwnPropertyNames(combat.grid).forEach(function(q) {
                let rgrid = combat.grid[q];
                Object.getOwnPropertyNames(rgrid).forEach(function (r) {
                    let hex = combat.grid[q][r];

                    // offset everything so the top left of the grid matches
                    // the top left of grid's canvas. we want to actually
                    // modify the vertices array in hex.
                    hex.center.x -= minX;
                    hex.center.y -= minY;
                    hex.vertices.forEach(function(unused, i, vertices) {
                        vertices[i].x -= minX;
                        vertices[i].y -= minY;
                    });

                    drawHex(canvasLayers[0].ctx, hex.vertices, "#00bb22");

                    if (hex.unit) {
                        drawUnit(canvasLayers[3].ctx,
                                 hex.center.x,
                                 hex.center.y,
                                 (hex.unit.friendly ?
                                  "#2088ff" :
                                  "red"));
                    }

                    // XXX: this is debugging, remove later
                    canvasLayers[2].ctx.font = "12px Courier New";
                    canvasLayers[2].ctx.fillStyle = "black";
                    canvasLayers[2].ctx.fillText(
                        q + ", " + r,
                        hex.center.x - (viewportHexRadius / 2),
                        hex.center.y);
                });
            });

            setKeys(viewport, viewportHexRadius);
            redraw();

            redrawEventQueue(combat.events[0], combat.events.slice(1));

            // once it's setup, progress the game
            $.ajax({
                url: "/combat_step",
                success: function(step_result) {
                    let step = JSON.parse(step_result);

                    console.log("step:", step);
                    redrawEventQueue(step.curr_event, step.events);
                },
            });
        }
    });
}

$( window ).on("load", onLoad);
        </script>

    <head>

    <body>
        <h1>boop</h1>
        <div id="unit-info">
            <div id="unit-info-name">
                &nbsp;
            </div>
            <div id="unit-info-action-points">
                &nbsp;
            </div>
        </div>
        <div id="canvas-row">
            <canvas id="theviewport" width=800 height=600>
            </canvas>
            <div id="event-queue-column">
                <h2>Next:</h2>
                <div id="event-queue">
                    <div id="event-template"></div>
                </div>
            </div>
        </div>
    </body>
</html>
