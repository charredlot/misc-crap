<html>

    <head>
        <script src="/static/jquery.3.4.1.min.js"></script>

        <script>
"use strict";
var grid = {};
var tiles;
var center = {x: 0, y: 0};
var cameraOffset = {dx: 0, dy: 0};
var sqrt3 = Math.sqrt(3);
var halfSqrt3 = Math.sqrt(3) / 2;

// this is the viewport canvas element that the user sees
var viewport;
var viewportCtx;
// the size of the hexes should be based on the visible viewport
var viewportHexRadius;

// this array of canvas elements hold the full grid, which might be bigger than
// the viewport. all the layers have the same dimensions
var canvasLayers;
var margin = 20;

function redraw() {
    viewportCtx.clearRect(0, 0, viewport.width, viewport.height);
    canvasLayers.forEach(function(layer) {
        viewportCtx.drawImage(layer.canvas, cameraOffset.dx, cameraOffset.dy);
    });
}

function setKeys() {
    let keybinds = {};
    
    keybinds["w".charCodeAt(0)] = function() { cameraOffset.dy += 10; },
    keybinds["a".charCodeAt(0)] = function() { cameraOffset.dx += 10; },
    keybinds["s".charCodeAt(0)] = function() { cameraOffset.dy -= 10; },
    keybinds["d".charCodeAt(0)] = function() { cameraOffset.dx -= 10; },
    console.log(keybinds);

    $(window).on("keypress", function(evt) {
        let f = keybinds[evt.keyCode];
        
        if (f === undefined) {
            return;
        }

        console.log(evt.keyCode, evt.code);

        let prevCameraOffset = Object.assign({}, cameraOffset);
        f();
        if ((prevCameraOffset.dx !== cameraOffset.dx) ||
            (prevCameraOffset.dy !== cameraOffset.dy)) {
            redraw();
        }

    });
}

function axialToPoint(q, r, radius) {
    return {
        x: radius * ((sqrt3 * q) + (halfSqrt3 * r)),
        y: radius * r * 3 / 2,
    }
}

// get all the hexagon vertices given the center point and a radius
function hexVertices(centerX, centerY, radius) {
    // start at the pointy bottom and go counterclockwise
    return [
        {x: centerX, y: centerY + radius},
        {x: centerX + (halfSqrt3 * radius), y: centerY + (radius / 2)},
        {x: centerX + (halfSqrt3 * radius), y: centerY - (radius / 2)},
        {x: centerX, y: centerY - radius},
        {x: centerX - (halfSqrt3 * radius), y: centerY - (radius / 2)},
        {x: centerX - (halfSqrt3 * radius), y: centerY + (radius / 2)},
    ];
}

// ctx is a canvas 2D context
// points is a list like [{x: x, y: y}, ...]
// it should have 6 points
function drawHex(ctx, points) {
    ctx.beginPath();
    let point = points[0];
    ctx.moveTo(point.x, point.y);
    for (let i = 1; i < points.length; i++) {
        point = points[i];
        ctx.lineTo(point.x, point.y);
    }
    ctx.closePath();

    ctx.fillStyle = "#00bb22";
    ctx.fill();

    ctx.strokeStyle = "black";
    ctx.stroke();
}

function drawUnit(ctx, centerX, centerY, fillStyle) {
    ctx.beginPath();
    ctx.arc(centerX,
            centerY,
            viewportHexRadius / 2,
            0,
            2 * Math.PI);
    ctx.fillStyle = fillStyle;
    ctx.fill();
}

function initLayers(width, height) {
    console.log("grid dimensions:", width, height);

    canvasLayers = [];
    for (let i = 0; i < 3; i++) {
        let c = document.createElement("canvas");
        c.width = width;
        c.height = height;

        canvasLayers.push({
            canvas: c,
            ctx: c.getContext("2d"),
        });
    }
}

function onLoad() {
    $.ajax({
        url: "/grid",
        success: function(result) {
            setKeys();

            viewport = document.getElementById("theviewport");
            viewportCtx = viewport.getContext('2d');
            viewportHexRadius = viewport.height / 20;

            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            // find the max size of a theoretical canvas that could hold the
            // entire grid. though the size of the grid is scaled to the
            // viewport. the viewport will just use an offset to figure out
            // which part of the grid is currently visible
            tiles = JSON.parse(result);
            tiles.forEach(function(tile) {
                let hex = {};

                if (grid[tile.q] === undefined) {
                    grid[tile.q] = {};
                }
                grid[tile.q][tile.r] = hex;

                hex.center = axialToPoint(tile.q, tile.r, viewportHexRadius);
                hex.vertices = hexVertices(hex.center.x, hex.center.y,
                                           viewportHexRadius);

                if (tile.unit) {
                    hex.unit = tile.unit;
                }

                hex.vertices.forEach(function(vertex) {
                    minX = Math.min(minX, vertex.x);
                    maxX = Math.max(maxX, vertex.x);
                    minY = Math.min(minY, vertex.y);
                    maxY = Math.max(maxY, vertex.y);
                });
            });

            minX -= margin;
            maxX += margin;
            minY -= margin;
            maxY += margin;

            console.log("x range:", minX, maxX, "y range:", minY, maxY);

            initLayers(maxX - minX, maxY - minY);

            Object.getOwnPropertyNames(grid).forEach(function(q) {
                let rgrid = grid[q];
                Object.getOwnPropertyNames(rgrid).forEach(function (r) {
                    let hex = grid[q][r];

                    // offset everything so the top left of the grid matches
                    // the top left of grid's canvas. we want to actually
                    // modify the vertices array in hex.
                    hex.center.x -= minX;
                    hex.center.y -= minY;
                    hex.vertices.forEach(function(unused, i, vertices) {
                        vertices[i].x -= minX;
                        vertices[i].y -= minY;
                    });

                    drawHex(canvasLayers[0].ctx, hex.vertices);

                    if (hex.unit) {
                        drawUnit(canvasLayers[2].ctx,
                                 hex.center.x,
                                 hex.center.y,
                                 (hex.unit.friendly ?
                                  "#2088ff" :
                                  "red"));
                    }
               
                    // XXX: this is debugging, remove later
                    canvasLayers[1].ctx.font = "8px Courier New";
                    canvasLayers[1].ctx.fillStyle = "black";
                    canvasLayers[1].ctx.fillText(
                        q + ", " + r,
                        hex.center.x - (viewportHexRadius / 2),
                        hex.center.y);
                });
            });
            redraw();
        }
    });
}

$( window ).on("load", onLoad);
        </script>

    <head>

    <body>
        <h1>boop</h1>
        <canvas id="theviewport" width=800 height=600>
        </canvas>
    </body>
</html>
