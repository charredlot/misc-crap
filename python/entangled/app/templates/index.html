<html>

    <head>
        <script src="/static/jquery.3.4.1.min.js"></script>

        <script>
"use strict";
var grid = {};
var tiles;
var center = {x: 0, y: 0};
var cameraOffset = {dx: 0, dy: 0};
var sqrt3 = Math.sqrt(3);
var halfSqrt3 = Math.sqrt(3) / 2;

// this is the viewport canvas element that the user sees
var viewport;
var viewportCtx;
// the size of the hexes should be based on the visible viewport
var viewportHexRadius;
var viewportDX;
var viewportDY;

// this array of canvas elements hold the full rgba(0, 0, 0, 0)grid, which might be bigger than
// the viewport. all the layers have the same dimensions
var canvasLayers;
var margin = 20;

function redraw() {
    viewportCtx.clearRect(0, 0, viewport.width, viewport.height);
    canvasLayers.forEach(function(layer) {
        viewportCtx.drawImage(layer.canvas, cameraOffset.dx, cameraOffset.dy);
    });
}

function hexFromAxial(q, r) {
    let rgrid = grid[q];
    if (!rgrid) {
        return;
    }

    return rgrid[r];
}

function setKeys(clickCanvas, hexRadius) {
    let keybinds = {};
    
    keybinds["w".charCodeAt(0)] = function() { cameraOffset.dy += 10; },
    keybinds["a".charCodeAt(0)] = function() { cameraOffset.dx += 10; },
    keybinds["s".charCodeAt(0)] = function() { cameraOffset.dy -= 10; },
    keybinds["d".charCodeAt(0)] = function() { cameraOffset.dx -= 10; },
    console.log(keybinds);

    $(window).on("keypress", function(evt) {
        let f = keybinds[evt.keyCode];
        
        if (f === undefined) {
            return;
        }

        console.log(evt.keyCode, evt.code);

        let prevCameraOffset = Object.assign({}, cameraOffset);
        f();
        if ((prevCameraOffset.dx !== cameraOffset.dx) ||
            (prevCameraOffset.dy !== cameraOffset.dy)) {
            redraw();
        }

    });

    let clickHandler = function(event, erase) {
        let x = (event.pageX
                 - clickCanvas.offsetLeft
                 - cameraOffset.dx
                 + viewportDX);
        let y = (event.pageY
                 - clickCanvas.offsetTop
                 - cameraOffset.dy
                 + viewportDY);

        // https://www.redblobgames.com/grids/hexagons/#pixel-to-hex
        let q = Math.round(((x / sqrt3) - (y / 3)) / hexRadius);
        let r = Math.round((y * 2 / 3) / hexRadius);

        // thanks for not having integers javascript
        if (Object.is(q, -0)) {
            q = 0;
        }

        if (Object.is(r, -0)) {
            r = 0;
        }

        let hex = grid[q][r];
        if (!hex) {
            return;
        }

        let vertices = hex.vertices;
        let ctx = canvasLayers[1].ctx;
        clearHex(ctx, vertices);
        if (!erase) {
            drawHex(ctx, vertices, "rgba(0, 39, 117, 0.3)");
        }
        redraw();
    };

    clickCanvas.addEventListener('click', function(event) {
        clickHandler(event, false);
    });
    clickCanvas.addEventListener('dblclick', function(event) {
        clickHandler(event, true);
    });

}

function axialToPoint(q, r, radius) {
    return {
        x: radius * ((sqrt3 * q) + (halfSqrt3 * r)),
        y: radius * r * 3 / 2,
    }
}

// get all the hexagon vertices given the center point and a radius
function hexVertices(centerX, centerY, radius) {
    // start at the pointy bottom and go counterclockwise
    return [
        {x: centerX, y: centerY + radius},
        {x: centerX + (halfSqrt3 * radius), y: centerY + (radius / 2)},
        {x: centerX + (halfSqrt3 * radius), y: centerY - (radius / 2)},
        {x: centerX, y: centerY - radius},
        {x: centerX - (halfSqrt3 * radius), y: centerY - (radius / 2)},
        {x: centerX - (halfSqrt3 * radius), y: centerY + (radius / 2)},
    ];
}

function drawHexPath(ctx, vertices) {
    ctx.beginPath();
    let vertex = vertices[0];
    ctx.moveTo(vertex.x, vertex.y);
    for (let i = 1; i < vertices.length; i++) {
        vertex = vertices[i];
        ctx.lineTo(vertex.x, vertex.y);
    }
    ctx.closePath();
}

// ctx is a canvas 2D context
// verticess is a list like [{x: x, y: y}, ...]
// it should have 6 vertices
function drawHex(ctx, vertices, fillStyle) {
    drawHexPath(ctx, vertices);

    ctx.fillStyle = fillStyle;
    ctx.fill();

    ctx.strokeStyle = "black";
    ctx.stroke();
}

function clearHex(ctx, vertices) {
    let op = ctx.globalCompositeOperation;
    ctx.globalCompositeOperation = 'destination-out';
    drawHexPath(ctx, vertices);
    ctx.fillStyle = "black";
    ctx.fill()
    ctx.globalCompositeOperation = op;
}

function drawUnit(ctx, centerX, centerY, fillStyle) {
    ctx.beginPath();
    ctx.arc(centerX,
            centerY,
            viewportHexRadius / 2,
            0,
            2 * Math.PI);
    ctx.fillStyle = fillStyle;
    ctx.fill();
}

function initLayers(width, height) {
    console.log("grid dimensions:", width, height);

    canvasLayers = [];
    for (let i = 0; i < 4; i++) {
        let c = document.createElement("canvas");
        c.width = width;
        c.height = height;

        canvasLayers.push({
            canvas: c,
            ctx: c.getContext("2d"),
        });
    }
}

function onLoad() {
    $.ajax({
        url: "/grid",
        success: function(result) {
            viewport = document.getElementById("theviewport");
            viewportCtx = viewport.getContext('2d');
            viewportHexRadius = viewport.height / 20;

            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            // find the max size of a theoretical canvas that could hold the
            // entire grid. though the size of the grid is scaled to the
            // viewport. the viewport will just use an offset to figure out
            // which part of the grid is currently visible
            tiles = JSON.parse(result);
            tiles.forEach(function(tile) {
                let hex = {};

                if (grid[tile.q] === undefined) {
                    grid[tile.q] = {};
                }
                grid[tile.q][tile.r] = hex;

                hex.center = axialToPoint(tile.q, tile.r, viewportHexRadius);
                hex.vertices = hexVertices(hex.center.x, hex.center.y,
                                           viewportHexRadius);

                if (tile.unit) {
                    hex.unit = tile.unit;
                }

                hex.vertices.forEach(function(vertex) {
                    minX = Math.min(minX, vertex.x);
                    maxX = Math.max(maxX, vertex.x);
                    minY = Math.min(minY, vertex.y);
                    maxY = Math.max(maxY, vertex.y);
                });
            });

            minX -= margin;
            maxX += margin;
            minY -= margin;
            maxY += margin;

            console.log("x range:", minX, maxX, "y range:", minY, maxY);

            viewportDX = minX;
            viewportDY = minY;
            initLayers(maxX - minX, maxY - minY);

            Object.getOwnPropertyNames(grid).forEach(function(q) {
                let rgrid = grid[q];
                Object.getOwnPropertyNames(rgrid).forEach(function (r) {
                    let hex = grid[q][r];

                    // offset everything so the top left of the grid matches
                    // the top left of grid's canvas. we want to actually
                    // modify the vertices array in hex.
                    hex.center.x -= minX;
                    hex.center.y -= minY;
                    hex.vertices.forEach(function(unused, i, vertices) {
                        vertices[i].x -= minX;
                        vertices[i].y -= minY;
                    });

                    drawHex(canvasLayers[0].ctx, hex.vertices, "#00bb22");

                    if (hex.unit) {
                        drawUnit(canvasLayers[3].ctx,
                                 hex.center.x,
                                 hex.center.y,
                                 (hex.unit.friendly ?
                                  "#2088ff" :
                                  "red"));
                    }
               
                    // XXX: this is debugging, remove later
                    canvasLayers[2].ctx.font = "8px Courier New";
                    canvasLayers[2].ctx.fillStyle = "black";
                    canvasLayers[2].ctx.fillText(
                        q + ", " + r,
                        hex.center.x - (viewportHexRadius / 2),
                        hex.center.y);
                });
            });

            setKeys(viewport, viewportHexRadius);
            redraw();
        }
    });
}

$( window ).on("load", onLoad);
        </script>

    <head>

    <body>
        <h1>boop</h1>
        <canvas id="theviewport" width=800 height=600>
        </canvas>
    </body>
</html>
