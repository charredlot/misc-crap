mod constants;
use self::constants::SBOX;

pub struct AESState {
    expanded_key: Vec<u8>,
    rounds: usize,
}

impl AESState {
    fn new(key: &[u8]) -> AESState {
        let key_size = key.len();

        let rounds: usize = match key_size {
            // from AES spec
            16 => 10,  // 128
            24 => 12,  // 192
            32 => 14,  // 256
            // XXX: return error instead of panicking
            _ => panic!("bad key len {}", key_size)
        };

        // XXX: could pack encrypt/decrypt in a closure like go does?
        AESState {
            expanded_key: AESState::expand_key(key),
            rounds: rounds,
        }
    }

    fn expand_key(key: &[u8]) -> Vec<u8> {
        // from the wiki for Rijndael key schedule
        let (n, b) = match key.len() {
            16 => (16, 176),
            24 => (24, 208),
            32 => (32, 240),
            // XXX: return error instead of panicking
            _ => panic!("bad key len {}", key.len())
        };

        let mut expanded: Vec<u8> = Vec::with_capacity(b);

        // put in original key
        for &b in key {
            expanded.push(b);
        }


        let mut rcon_i = 1;
        let mut t = [0u8; 4];
        // XXX: could rust optimize better with local length variable?
        while expanded.len() < b {
            for j in 0..4 {
                t[j] = expanded[expanded.len() + j - 4];
            }

            if expanded.len() % n == 0 {
                rijndael_core(&mut t, rcon_i);
                rcon_i += 1;
            }

            if n == 32 && (expanded.len() % 32 == 16) {
                // 256-bit keys have an extra sbox step for some reason
                for j in 0..4 {
                    t[j] = SBOX[t[j] as usize];
                }
            }

            for j in 0..4 {
                let prev = expanded[expanded.len() - n];
                expanded.push(t[j] ^ prev);
            }
        }

        expanded
    }
}

fn rijndael_core(t: &mut [u8; 4], rcon_i: usize) {
    const RCON: [u8; 256] = [
        0x8du8, 0x01u8, 0x02u8, 0x04u8, 0x08u8, 0x10u8, 0x20u8, 0x40u8,
        0x80u8, 0x1bu8, 0x36u8, 0x6cu8, 0xd8u8, 0xabu8, 0x4du8, 0x9au8,
        0x2fu8, 0x5eu8, 0xbcu8, 0x63u8, 0xc6u8, 0x97u8, 0x35u8, 0x6au8,
        0xd4u8, 0xb3u8, 0x7du8, 0xfau8, 0xefu8, 0xc5u8, 0x91u8, 0x39u8,
        0x72u8, 0xe4u8, 0xd3u8, 0xbdu8, 0x61u8, 0xc2u8, 0x9fu8, 0x25u8,
        0x4au8, 0x94u8, 0x33u8, 0x66u8, 0xccu8, 0x83u8, 0x1du8, 0x3au8,
        0x74u8, 0xe8u8, 0xcbu8, 0x8du8, 0x01u8, 0x02u8, 0x04u8, 0x08u8,
        0x10u8, 0x20u8, 0x40u8, 0x80u8, 0x1bu8, 0x36u8, 0x6cu8, 0xd8u8,
        0xabu8, 0x4du8, 0x9au8, 0x2fu8, 0x5eu8, 0xbcu8, 0x63u8, 0xc6u8,
        0x97u8, 0x35u8, 0x6au8, 0xd4u8, 0xb3u8, 0x7du8, 0xfau8, 0xefu8,
        0xc5u8, 0x91u8, 0x39u8, 0x72u8, 0xe4u8, 0xd3u8, 0xbdu8, 0x61u8,
        0xc2u8, 0x9fu8, 0x25u8, 0x4au8, 0x94u8, 0x33u8, 0x66u8, 0xccu8,
        0x83u8, 0x1du8, 0x3au8, 0x74u8, 0xe8u8, 0xcbu8, 0x8du8, 0x01u8,
        0x02u8, 0x04u8, 0x08u8, 0x10u8, 0x20u8, 0x40u8, 0x80u8, 0x1bu8,
        0x36u8, 0x6cu8, 0xd8u8, 0xabu8, 0x4du8, 0x9au8, 0x2fu8, 0x5eu8,
        0xbcu8, 0x63u8, 0xc6u8, 0x97u8, 0x35u8, 0x6au8, 0xd4u8, 0xb3u8,
        0x7du8, 0xfau8, 0xefu8, 0xc5u8, 0x91u8, 0x39u8, 0x72u8, 0xe4u8,
        0xd3u8, 0xbdu8, 0x61u8, 0xc2u8, 0x9fu8, 0x25u8, 0x4au8, 0x94u8,
        0x33u8, 0x66u8, 0xccu8, 0x83u8, 0x1du8, 0x3au8, 0x74u8, 0xe8u8,
        0xcbu8, 0x8du8, 0x01u8, 0x02u8, 0x04u8, 0x08u8, 0x10u8, 0x20u8,
        0x40u8, 0x80u8, 0x1bu8, 0x36u8, 0x6cu8, 0xd8u8, 0xabu8, 0x4du8,
        0x9au8, 0x2fu8, 0x5eu8, 0xbcu8, 0x63u8, 0xc6u8, 0x97u8, 0x35u8,
        0x6au8, 0xd4u8, 0xb3u8, 0x7du8, 0xfau8, 0xefu8, 0xc5u8, 0x91u8,
        0x39u8, 0x72u8, 0xe4u8, 0xd3u8, 0xbdu8, 0x61u8, 0xc2u8, 0x9fu8,
        0x25u8, 0x4au8, 0x94u8, 0x33u8, 0x66u8, 0xccu8, 0x83u8, 0x1du8,
        0x3au8, 0x74u8, 0xe8u8, 0xcbu8, 0x8du8, 0x01u8, 0x02u8, 0x04u8,
        0x08u8, 0x10u8, 0x20u8, 0x40u8, 0x80u8, 0x1bu8, 0x36u8, 0x6cu8,
        0xd8u8, 0xabu8, 0x4du8, 0x9au8, 0x2fu8, 0x5eu8, 0xbcu8, 0x63u8,
        0xc6u8, 0x97u8, 0x35u8, 0x6au8, 0xd4u8, 0xb3u8, 0x7du8, 0xfau8,
        0xefu8, 0xc5u8, 0x91u8, 0x39u8, 0x72u8, 0xe4u8, 0xd3u8, 0xbdu8,
        0x61u8, 0xc2u8, 0x9fu8, 0x25u8, 0x4au8, 0x94u8, 0x33u8, 0x66u8,
        0xccu8, 0x83u8, 0x1du8, 0x3au8, 0x74u8, 0xe8u8, 0xcbu8, 0x8du8,
    ];

    let tmp = t[0];
    t[0] = t[1];
    t[1] = t[2];
    t[2] = t[3];
    t[3] = tmp;

    for i in 0..4 {
        t[i] = SBOX[t[i] as usize];
    }
    t[0] = t[0] ^ RCON[rcon_i];
}

struct KeyExpansionTest<'a, 'b> {
    key: &'a [u8],
    expanded: &'b [u8],
}
fn expand_key_test() {
    let tests = [
        KeyExpansionTest {
            key: &[0u8; 16],
            expanded: &[
                0x00u8, 0x00u8, 0x00u8, 0x00u8, 0x00u8, 0x00u8, 0x00u8, 0x00u8,
                0x00u8, 0x00u8, 0x00u8, 0x00u8, 0x00u8, 0x00u8, 0x00u8, 0x00u8,
                0x62u8, 0x63u8, 0x63u8, 0x63u8, 0x62u8, 0x63u8, 0x63u8, 0x63u8,
                0x62u8, 0x63u8, 0x63u8, 0x63u8, 0x62u8, 0x63u8, 0x63u8, 0x63u8,
                0x9bu8, 0x98u8, 0x98u8, 0xc9u8, 0xf9u8, 0xfbu8, 0xfbu8, 0xaau8,
                0x9bu8, 0x98u8, 0x98u8, 0xc9u8, 0xf9u8, 0xfbu8, 0xfbu8, 0xaau8,
                0x90u8, 0x97u8, 0x34u8, 0x50u8, 0x69u8, 0x6cu8, 0xcfu8, 0xfau8,
                0xf2u8, 0xf4u8, 0x57u8, 0x33u8, 0x0bu8, 0x0fu8, 0xacu8, 0x99u8,
                0xeeu8, 0x06u8, 0xdau8, 0x7bu8, 0x87u8, 0x6au8, 0x15u8, 0x81u8,
                0x75u8, 0x9eu8, 0x42u8, 0xb2u8, 0x7eu8, 0x91u8, 0xeeu8, 0x2bu8,
                0x7fu8, 0x2eu8, 0x2bu8, 0x88u8, 0xf8u8, 0x44u8, 0x3eu8, 0x09u8,
                0x8du8, 0xdau8, 0x7cu8, 0xbbu8, 0xf3u8, 0x4bu8, 0x92u8, 0x90u8,
                0xecu8, 0x61u8, 0x4bu8, 0x85u8, 0x14u8, 0x25u8, 0x75u8, 0x8cu8,
                0x99u8, 0xffu8, 0x09u8, 0x37u8, 0x6au8, 0xb4u8, 0x9bu8, 0xa7u8,
                0x21u8, 0x75u8, 0x17u8, 0x87u8, 0x35u8, 0x50u8, 0x62u8, 0x0bu8,
                0xacu8, 0xafu8, 0x6bu8, 0x3cu8, 0xc6u8, 0x1bu8, 0xf0u8, 0x9bu8,
                0x0eu8, 0xf9u8, 0x03u8, 0x33u8, 0x3bu8, 0xa9u8, 0x61u8, 0x38u8,
                0x97u8, 0x06u8, 0x0au8, 0x04u8, 0x51u8, 0x1du8, 0xfau8, 0x9fu8,
                0xb1u8, 0xd4u8, 0xd8u8, 0xe2u8, 0x8au8, 0x7du8, 0xb9u8, 0xdau8,
                0x1du8, 0x7bu8, 0xb3u8, 0xdeu8, 0x4cu8, 0x66u8, 0x49u8, 0x41u8,
                0xb4u8, 0xefu8, 0x5bu8, 0xcbu8, 0x3eu8, 0x92u8, 0xe2u8, 0x11u8,
                0x23u8, 0xe9u8, 0x51u8, 0xcfu8, 0x6fu8, 0x8fu8, 0x18u8, 0x8eu8,
                ],
        },
    ];

    for test in &tests {
        let expanded = AESState::expand_key(test.key);
        for (i, (&tb, b)) in test.expanded.iter().zip(expanded).enumerate() {
            if b != tb {
                panic!("expand_key_test expected {} got {} at {}", tb, b, i);
            }
        }
    }
}

pub fn aes_test() {
    expand_key_test();
}
